\chapter{Implementation}

% The implementation should look at any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex, perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?

% It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant? Your implementation might well be described in the same chapter as Problems (see below).

% working within context of other projects, have to keep conventions in mind, although better ways of doing things always welcome

Instead of going through the minute details of how the architecture described in \myref{design} is implemented, this chapter will focus on how the functionality for the final software features was achieved. One common topic - datastore interaction - is tackled first.

% TODO note which libraries / parent code turned out to not be so suitable

\section{Datastore access}
The |dao| module merits further discussion.

When the |upsert| method generates |id|s for the incoming data, it currently simply generates UUID4 (random unique identifiers). \myref{design-dao} uses |Account| to illustrate the point that |id| generation could be overridden on a per-DAO-class basis. In the case of |Account| they will actually usually be specified (the users choose a username and that is used as the |id|), so a random number will \emph{not} be generated.

% TODO pyes

\section{Implementing The Main Application}

\subsection{The Basics}
\label{impl-hard-basics}

The one crowdsourcing basic function which has to be present in a project which hopes to get any input from its audience is submission of information. One step further is allowing users to view the submitted content. These were thought to be quite easy to achieve at the beginning of the project, which turned out to be possibly the greatest miscalculation in the whole piece of work.

\subsubsection{Search For Scholarly Funding Opportunities}
\label{impl-facetview}
\label{impl-search}
The combined search/view page is an important part of the user interface, allowing the user to drill down through (potentially) a lot of semistructured data to find what they want.

The facetview project is a pure Javascript faceted search interface to elasticsearch which incorporates the faceted search concept described in \myref{faceted-search}. It is a jQuery plugin which has configurable initilisation. The general idea is that it will generate and put all its content inside an HTML |<div>| element identified by a certain |class| or |id| attribute (the details are up to the developer).

In the case of this page, the effort was mostly configuring facetview to show all the fields the data had and surround the content of those fields with appropriate formatting. For example, the name of the field (e.g. ``Homepage'') would be underlined in contrast to the content of the field. Fields also (usually) need to sit on separate lines and facetview had to be configured to put them in separate |<div>|s since these are block HTML elements.

By default facetview would query absolutely everything in the index, which meant that user accounts were showing up together with funding opportunities and funders. On the other hand, restricting it to show only one document type would not work either, since both funders and funding opportunities are of interest to the users (who can then refine the results they are seeing). This also meant that a default type had to be chosen, since testing showed that showing both result types, while technically possible, was confusing for users. Funders are now shown by default just due to the testing data for funders being of higher quality than funding opportunities and demonstrating facetview's capabilities better. This default required a more intuitive way of switching the document types being shown than ``click on Funders to deactivate the filter, then click on the other one to activate that'' - two specific buttons now take care of switching to either document type.
%TODO include screenshot of buttons here

%TODO describe how facetview is configured

%TODO describe how searches can be shared just by copying the url of the search page here

On top of the configuration, there was a significant problem with actually using facetview in the fundfind codebase. The parent IDFind codebase was still using an older version (1.3) of the Bootstrap HTML user interface library. Facetview was using an incompatible 2.x version. This was known before the mid-project demonstration, but took so long to fix that the search page had to be demonstrated using an iframe (embedding another page inside it), which is a big no-no in the modern user experience field. (One explanation puts it really well: ``They break the one-document-per-URL paradigm, which is essential for the proper functioning of the web (think bookmarks, deep-links, search engines, ...).'' \cite{iframe-evil}.)

Furthermore, facetview was expected to be far easier to configure than it was. Using a component and even seeing development being done on a component clearly do not equate to being able to use said component in software - the author had not actually tried facetview integration, although it \emph{looked} easy.

\subsubsection{Submitting Information about Funders and Opportunities}
\label{impl-submitting}

The information submission pages were made manually in the parent IDFind project. There is, in fact, a library which will generate forms and can be configured to validate them - WTForms \cite{wtforms}. Unfortunately, this was discovered a little too late - the submission pages had been written and time had to be divided between other features.

An interesting elasticsearch feature helped here. It is possible to ask elasticsearch what fields the incoming documents contained by issuing an HTTP |GET| request (e.g. with a browser) to the |_mapping| path of an index, like this:
\\ |http://localhost:9200/fundfind/_mapping|

which promptly answers with something similar to:
\begin{verbatim}
{
	"fundfind": { # index name
		"funder": { # types of submitted documents
			"properties": {
				"created": {
					"type": "date",
					"format": "dateOptionalTime"
				},
				"description": {
					"type": "string"
				},
				"homepage": {
					"type": "string"
				},
[...]
\end{verbatim}

This lists all the properties that all documents submitted to the |fundfind| index have had and how they were analysed (e.g. date versus string), grouped by document type. Not all documents need to have all the properties of course - this is just a list of all the properties that elasticsearch has had to analyse. Which is all that is necessary for configuring facetview, since it can deal with semistructured data with missing fields in it just like the datastore can.

jQuery was used to create the ``add more'' buttons on the information submission pages. Adding more useful links adds more text input fields, while adding more tags extends the tags input field. Processing the extra |useful_links| in the |importer| module was an interesting challenge - at first, new elements created using jQuery were given numbers at the end of their names, like |useful_link1|, |useful_link2| and so on. The back-end code then iterated through a loop a 100 times, trying to get content from these elements (which would of course break if anybody ever submitted more than 100 useful links - it would discard everything above a 100). Then it turned out it is possible to declare the |input| element's name attribute as follows: |name="useful_links[]| (note the square brackets). Apparently, this is supposed to signal to the web server that this is an incoming list of values. So Flask's underlying webserver, Werkzeug, provided the |getlist()| function on the HTTP request object, to deal with this situation.

FundFind does |request.values.getlist('useful_links[]')| and then iterates over the Python list this returns in a conventional Python way |for link in list|, instead of using integers on a list of an unknown size. It should be noted this feature did not change much in FundFind, although it was written by the same author for the parent IDFind project.

\subsubsection{Create Profiles}
\label{impl-profiles}
% chapter 3 says 	\item |password| - a hash of the user's password. See \myref{impl-profiles} for more details.
Profiles are handled almost entirely by the Flask-Login extension, except for registation of accounts. \cite{flask-login}

This uses the Flask views described in \myref{design-web}, Flask blueprints and WTForms to create several actions - registering a user, logging in and logging out. Flask blueprints are a way of sharing common operations, such as rendering a particular template and processing a particular form - if another application wanted to use FundFind's user registration form, it would just need the blueprint file and would need to call |app.register_blueprint()| in their equivalent of the |web| module.

\subsection{Advanced Features}

\subsubsection{Harvest Funding Data From Machine-Readable Sources}
%TODO this is pure fucking fiction, fix it after doing the work!
This was implemented using the Feedparser \cite{feedparser} library. After loading the feeds, some mapping of keys was done, e.g. ``name'' was renamed to ``title''. Unknown keys were left as they are and saved alongside the other keys, so that searching would catch them and more importantly, so that data would not be lost. This makes this RSS harvester design somewhat more futureproof than usual, i.e. if the data sources decide to add values to the data the new information would be indexed anyway. It would not display in the search results with the current facetview configuration (having to specify how to display fields explicitly) but if that were upgraded, RSS feeds could simply be chucked into the system with little more than conversion to JSON.

Feedparser behaved quite well, following the Python convention of ``it just works'' i.e. sensible default settings out of the box and supporting the widest possible range of inputs (feed formats like RSS, Atom etc. in this case). Its documentation does contain a pretty ominous sentence:

\begin{shadequote}
Values are returned as Python Unicode strings (except when they?re not ? see Character Encoding Detection for all the gory details).
\par\emph{Feedparser documentation \cite{feedparser-ominous}}
\end{shadequote}

\subsubsection{Tagging}
Both ``Tagging Research as "Potentially of Interest to" Users And Groups'' and ``Specify Affiliation and Interests'' fall under this category. These were actually pretty easy - all that was necessary was to let users put in a comma-separated string. The string was then parsed and cleaned up, first by chunking it up into a list using Python's |.split(",")|  string method and the |importer.Importer._clean_list| method described in \myref{design-importer}. The ``add more'' button on the interface was added as described above in \myref{impl-submitting}.

\subsubsection{Responsive Mobile Web Design}
\label{impl-mobile}
This was done in a very simple way - sticking to using Bootstrap 2.3, the newest (at the time) version of Twitter's Bootstrap library even though it caused the major upgrade pains described above, and using its mobile-friendly version (so a question of loading the right files). Luckily, the the Flask-Bootstrap \cite{flask-bootstrap} extension was discovered before \emph{too} much time was spent just to get it to load in the right place. Apparently, one is supposed to put Javascript components at the bottom of the HTML page, so the rest of the content can load - if they are in |<head>| the browser \emph{must} use blocking, synchronous loading and wait for them to arrive before doing anything else.

\subsubsection{RESTful API}
\label{impl-api}

FundFind detects whether the request wants a JSON API response or the HTML user interface by looking at the request URL - if it ends with |'.json'|, it serves a JSON response (if the route supports it - e.g. the homepage at |'/'| does not serve JSON responses and will serve HTML anyway if asked).

\subsubsection{Suggesting Relevant Historical Data}

Coded as pure Javascript since all that is really needed is an AJAX call to the Gateway to Research API, which will happily return JSON. The |GTRConsumer| class uses HTTP GET requests to communicate with the Gateway to Research API. Its |suggest| method just uses the API's |/search| HTTP GET route to look for projects which contain the user's query to FundFind.

It does not currently process the query in any way, just asks the GtR API to give it back everything it thinks contains a particular string. The GtR API may actually do clever processing and include ``similar results'' in the resultset - it does not currently do that, but is in active development and may well change.

% \subsection{The Dropped Features}
% % TODO add all the dropped features from chapter 2, Initial Requirements here
% The decision to drop some features came after some design and exploratory technical work had been done.
% 
% \subsubsection{Harvesting Funding Data From E-mail Digests}
% \label{impl-email-parse}
% % chap2 says It is far easier to process RSS feeds such as the EPSRC Open Calls RSS Feed \cite{epsrc-rss} than it was to process the EPSRC Funding Call E-mail Alerts, as discussed in \myref{impl-email-parse}.
%fundfind.email.harvester@gmail.com